// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: activities.sql

package db

import (
	"context"
	"encoding/json"
)

const createActivity = `-- name: CreateActivity :one
INSERT INTO
    activities (
        title,
        start_date,
        end_date,
        venue,
        host,
        metadata
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, title, start_date, end_date, venue, host, metadata, created_at, updated_at, is_deleted
`

type CreateActivityParams struct {
	Title     string          `json:"title"`
	StartDate Date            `json:"start_date"`
	EndDate   Date            `json:"end_date"`
	Venue     *string         `json:"venue"`
	Host      *string         `json:"host"`
	Metadata  json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRowContext(ctx, createActivity,
		arg.Title,
		arg.StartDate,
		arg.EndDate,
		arg.Venue,
		arg.Host,
		arg.Metadata,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartDate,
		&i.EndDate,
		&i.Venue,
		&i.Host,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const deleteActivity = `-- name: DeleteActivity :exec
UPDATE activities SET is_deleted = 'Y' WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteActivity, id)
	return err
}

const findActivity = `-- name: FindActivity :one
SELECT id, title, start_date, end_date, venue, host, metadata, created_at, updated_at, is_deleted FROM activities WHERE id = $1
`

func (q *Queries) FindActivity(ctx context.Context, id int32) (Activity, error) {
	row := q.db.QueryRowContext(ctx, findActivity, id)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartDate,
		&i.EndDate,
		&i.Venue,
		&i.Host,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const findActivityByStartDate = `-- name: FindActivityByStartDate :many
SELECT id, title, start_date, end_date, venue, host, metadata, created_at, updated_at, is_deleted FROM activities WHERE start_date = $1
`

func (q *Queries) FindActivityByStartDate(ctx context.Context, startDate Date) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, findActivityByStartDate, startDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.Venue,
			&i.Host,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findActivityByTitle = `-- name: FindActivityByTitle :many
SELECT id, title, start_date, end_date, venue, host, metadata, created_at, updated_at, is_deleted FROM activities WHERE title LIKE '%$1%'
`

func (q *Queries) FindActivityByTitle(ctx context.Context) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, findActivityByTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.Venue,
			&i.Host,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivities = `-- name: ListActivities :many
SELECT id, title, start_date, end_date, venue, host, metadata, created_at, updated_at, is_deleted
FROM activities
WHERE
    is_deleted = 'N'
ORDER BY start_date DESC
`

func (q *Queries) ListActivities(ctx context.Context) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.Venue,
			&i.Host,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllActivities = `-- name: ListAllActivities :many
SELECT id, title, start_date, end_date, venue, host, metadata, created_at, updated_at, is_deleted FROM activities ORDER BY start_date DESC
`

func (q *Queries) ListAllActivities(ctx context.Context) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listAllActivities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.Venue,
			&i.Host,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActivity = `-- name: UpdateActivity :exec
UPDATE activities
SET
    title = $1,
    start_date = $2,
    end_date = $3,
    venue = $4,
    host = $5,
    metadata = $6,
    updated_at = NOW()
WHERE
    id = $7
`

type UpdateActivityParams struct {
	Title     string          `json:"title"`
	StartDate Date            `json:"start_date"`
	EndDate   Date            `json:"end_date"`
	Venue     *string         `json:"venue"`
	Host      *string         `json:"host"`
	Metadata  json.RawMessage `json:"metadata"`
	ID        int32           `json:"id"`
}

func (q *Queries) UpdateActivity(ctx context.Context, arg UpdateActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateActivity,
		arg.Title,
		arg.StartDate,
		arg.EndDate,
		arg.Venue,
		arg.Host,
		arg.Metadata,
		arg.ID,
	)
	return err
}
