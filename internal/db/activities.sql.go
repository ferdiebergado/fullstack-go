// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: activities.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const countActiveActivities = `-- name: CountActiveActivities :one
SELECT COUNT(*) FROM active_activities
`

func (q *Queries) CountActiveActivities(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveActivities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivities = `-- name: CountActivities :one
SELECT COUNT(*) FROM activities
`

func (q *Queries) CountActivities(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivity = `-- name: CreateActivity :one
INSERT INTO
    activities (
        title,
        start_date,
        end_date,
        venue_id,
        host_id,
        metadata
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at
`

type CreateActivityParams struct {
	Title     string          `json:"title"`
	StartDate Date            `json:"start_date"`
	EndDate   Date            `json:"end_date"`
	VenueID   int32           `json:"venue_id"`
	HostID    int32           `json:"host_id"`
	Metadata  json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRowContext(ctx, createActivity,
		arg.Title,
		arg.StartDate,
		arg.EndDate,
		arg.VenueID,
		arg.HostID,
		arg.Metadata,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartDate,
		&i.EndDate,
		&i.VenueID,
		&i.HostID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteActivity = `-- name: DeleteActivity :exec
UPDATE active_activities SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteActivity, id)
	return err
}

const findActiveActivitiesByStartDate = `-- name: FindActiveActivitiesByStartDate :many
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host FROM active_activity_details WHERE start_date = $1
`

func (q *Queries) FindActiveActivitiesByStartDate(ctx context.Context, startDate Date) ([]ActiveActivityDetail, error) {
	rows, err := q.db.QueryContext(ctx, findActiveActivitiesByStartDate, startDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveActivityDetail
	for rows.Next() {
		var i ActiveActivityDetail
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.VenueID,
			&i.HostID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Venue,
			&i.Region,
			&i.Host,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findActiveActivitiesByTitle = `-- name: FindActiveActivitiesByTitle :many
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host FROM active_activity_details WHERE title LIKE '%$1%'
`

func (q *Queries) FindActiveActivitiesByTitle(ctx context.Context) ([]ActiveActivityDetail, error) {
	rows, err := q.db.QueryContext(ctx, findActiveActivitiesByTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveActivityDetail
	for rows.Next() {
		var i ActiveActivityDetail
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.VenueID,
			&i.HostID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Venue,
			&i.Region,
			&i.Host,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findActiveActivity = `-- name: FindActiveActivity :one
SELECT id FROM active_activities WHERE id = $1
`

func (q *Queries) FindActiveActivity(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, findActiveActivity, id)
	err := row.Scan(&id)
	return id, err
}

const findActiveActivityDetails = `-- name: FindActiveActivityDetails :one
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host FROM active_activity_details WHERE id = $1
`

func (q *Queries) FindActiveActivityDetails(ctx context.Context, id int64) (ActiveActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, findActiveActivityDetails, id)
	var i ActiveActivityDetail
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartDate,
		&i.EndDate,
		&i.VenueID,
		&i.HostID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Venue,
		&i.Region,
		&i.Host,
	)
	return i, err
}

const findActivitiesByStartDate = `-- name: FindActivitiesByStartDate :many
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host FROM activity_details WHERE start_date = $1
`

func (q *Queries) FindActivitiesByStartDate(ctx context.Context, startDate Date) ([]ActivityDetail, error) {
	rows, err := q.db.QueryContext(ctx, findActivitiesByStartDate, startDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityDetail
	for rows.Next() {
		var i ActivityDetail
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.VenueID,
			&i.HostID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Venue,
			&i.Region,
			&i.Host,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findActivitiesByTitle = `-- name: FindActivitiesByTitle :many
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host FROM activity_details WHERE title LIKE '%$1%'
`

func (q *Queries) FindActivitiesByTitle(ctx context.Context) ([]ActivityDetail, error) {
	rows, err := q.db.QueryContext(ctx, findActivitiesByTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityDetail
	for rows.Next() {
		var i ActivityDetail
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.VenueID,
			&i.HostID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Venue,
			&i.Region,
			&i.Host,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findActivity = `-- name: FindActivity :one
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host FROM activity_details WHERE id = $1
`

func (q *Queries) FindActivity(ctx context.Context, id int64) (ActivityDetail, error) {
	row := q.db.QueryRowContext(ctx, findActivity, id)
	var i ActivityDetail
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.StartDate,
		&i.EndDate,
		&i.VenueID,
		&i.HostID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Venue,
		&i.Region,
		&i.Host,
	)
	return i, err
}

const listActiveActivities = `-- name: ListActiveActivities :many
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host, COUNT(*) OVER () AS total_items
FROM active_activity_details
WHERE
    COALESCE($5, '') = ''
    OR title LIKE $5
ORDER BY
    CASE
        WHEN $1 = 'title'
        AND $2 = 'ASC' THEN title
    END ASC,
    CASE
        WHEN $1 = 'title'
        AND $2 = 'DESC' THEN title
    END DESC,
    CASE
        WHEN $1 = 'start_date'
        AND $2 = 'ASC' THEN start_date
    END ASC,
    CASE
        WHEN $1 = 'start_date'
        AND $2 = 'DESC' THEN start_date
    END DESC,
    CASE
        WHEN $1 = 'end_date'
        AND $2 = 'ASC' THEN end_date
    END ASC,
    CASE
        WHEN $1 = 'end_date'
        AND $2 = 'DESC' THEN end_date
    END DESC,
    CASE
        WHEN $1 = 'venue'
        AND $2 = 'ASC' THEN venue
    END ASC,
    CASE
        WHEN $1 = 'venue'
        AND $2 = 'DESC' THEN venue
    END DESC,
    CASE
        WHEN $1 = 'host'
        AND $2 = 'ASC' THEN host
    END ASC,
    CASE
        WHEN $1 = 'host'
        AND $2 = 'DESC' THEN host
    END DESC
LIMIT $3
OFFSET
    $4
`

type ListActiveActivitiesParams struct {
	Column1 *string `json:"column_1"`
	Column2 *string `json:"column_2"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
	Column5 *string `json:"column_5"`
}

type ListActiveActivitiesRow struct {
	ID         int64           `json:"id"`
	Title      string          `json:"title"`
	StartDate  Date            `json:"start_date"`
	EndDate    Date            `json:"end_date"`
	VenueID    int32           `json:"venue_id"`
	HostID     int32           `json:"host_id"`
	Metadata   json.RawMessage `json:"metadata"`
	CreatedAt  time.Time       `json:"created_at"`
	UpdatedAt  time.Time       `json:"updated_at"`
	DeletedAt  sql.NullTime    `json:"deleted_at"`
	Venue      string          `json:"venue"`
	Region     string          `json:"region"`
	Host       string          `json:"host"`
	TotalItems int64           `json:"total_items"`
}

func (q *Queries) ListActiveActivities(ctx context.Context, arg ListActiveActivitiesParams) ([]ListActiveActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveActivities,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveActivitiesRow
	for rows.Next() {
		var i ListActiveActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.VenueID,
			&i.HostID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Venue,
			&i.Region,
			&i.Host,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivities = `-- name: ListActivities :many
SELECT id, title, start_date, end_date, venue_id, host_id, metadata, created_at, updated_at, deleted_at, venue, region, host, COUNT(*) OVER () AS total_items
FROM activity_details
WHERE
    COALESCE($5, '') = ''
    OR title LIKE $5
ORDER BY
    CASE
        WHEN $1 = 'title'
        AND $2 = 'ASC' THEN title
    END ASC,
    CASE
        WHEN $1 = 'title'
        AND $2 = 'DESC' THEN title
    END DESC,
    CASE
        WHEN $1 = 'start_date'
        AND $2 = 'ASC' THEN start_date
    END ASC,
    CASE
        WHEN $1 = 'start_date'
        AND $2 = 'DESC' THEN start_date
    END DESC,
    CASE
        WHEN $1 = 'end_date'
        AND $2 = 'ASC' THEN end_date
    END ASC,
    CASE
        WHEN $1 = 'end_date'
        AND $2 = 'DESC' THEN end_date
    END DESC,
    CASE
        WHEN $1 = 'venue'
        AND $2 = 'ASC' THEN venue
    END ASC,
    CASE
        WHEN $1 = 'venue'
        AND $2 = 'DESC' THEN venue
    END DESC,
    CASE
        WHEN $1 = 'host'
        AND $2 = 'ASC' THEN host
    END ASC,
    CASE
        WHEN $1 = 'host'
        AND $2 = 'DESC' THEN host
    END DESC
LIMIT $3
OFFSET
    $4
`

type ListActivitiesParams struct {
	Column1 *string `json:"column_1"`
	Column2 *string `json:"column_2"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
	Column5 *string `json:"column_5"`
}

type ListActivitiesRow struct {
	ID         int64           `json:"id"`
	Title      string          `json:"title"`
	StartDate  Date            `json:"start_date"`
	EndDate    Date            `json:"end_date"`
	VenueID    int32           `json:"venue_id"`
	HostID     int32           `json:"host_id"`
	Metadata   json.RawMessage `json:"metadata"`
	CreatedAt  time.Time       `json:"created_at"`
	UpdatedAt  time.Time       `json:"updated_at"`
	DeletedAt  sql.NullTime    `json:"deleted_at"`
	Venue      string          `json:"venue"`
	Region     string          `json:"region"`
	Host       string          `json:"host"`
	TotalItems int64           `json:"total_items"`
}

func (q *Queries) ListActivities(ctx context.Context, arg ListActivitiesParams) ([]ListActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listActivities,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActivitiesRow
	for rows.Next() {
		var i ListActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.StartDate,
			&i.EndDate,
			&i.VenueID,
			&i.HostID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Venue,
			&i.Region,
			&i.Host,
			&i.TotalItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreActivity = `-- name: RestoreActivity :exec
UPDATE activities SET deleted_at = NULL WHERE id = $1
`

func (q *Queries) RestoreActivity(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, restoreActivity, id)
	return err
}

const updateActivity = `-- name: UpdateActivity :exec
UPDATE active_activities
SET
    title = $1,
    start_date = $2,
    end_date = $3,
    venue_id = $4,
    host_id = $5,
    metadata = $6,
    updated_at = NOW()
WHERE
    id = $7
`

type UpdateActivityParams struct {
	Title     string          `json:"title"`
	StartDate Date            `json:"start_date"`
	EndDate   Date            `json:"end_date"`
	VenueID   int32           `json:"venue_id"`
	HostID    int32           `json:"host_id"`
	Metadata  json.RawMessage `json:"metadata"`
	ID        int64           `json:"id"`
}

func (q *Queries) UpdateActivity(ctx context.Context, arg UpdateActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateActivity,
		arg.Title,
		arg.StartDate,
		arg.EndDate,
		arg.VenueID,
		arg.HostID,
		arg.Metadata,
		arg.ID,
	)
	return err
}
